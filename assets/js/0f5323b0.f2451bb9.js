"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8581],{4820:(e,n,s)=>{s.d(n,{ZP:()=>a});var t=s(24246),i=s(71670);function r(e){const n=Object.assign({admonition:"admonition",p:"p",a:"a"},(0,i.a)(),e.components);return(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Please refer to the ",(0,t.jsx)(n.a,{href:"../typescript",children:"TypeScript"})," page for information about the types and interfaces referenced below."]})})}const a=function(e={}){const{wrapper:n}=Object.assign({},(0,i.a)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(r,e)})):r(e)}},97515:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var t=s(24246),i=s(71670),r=s(4820);const a={title:"Import",description:"Convert SQL and other formats to query builder objects"},o=void 0,l={id:"api/import",title:"Import",description:"Convert SQL and other formats to query builder objects",source:"@site/versioned_docs/version-4/api/import.mdx",sourceDirName:"api",slug:"/api/import",permalink:"/docs/4/api/import",draft:!1,unlisted:!1,editUrl:"https://github.com/react-querybuilder/react-querybuilder/edit/main/website/versioned_docs/version-4/api/import.mdx",tags:[],version:"4",frontMatter:{title:"Import",description:"Convert SQL and other formats to query builder objects"},sidebar:"mySidebar",previous:{title:"Export",permalink:"/docs/4/api/export"},next:{title:"Validation",permalink:"/docs/4/api/validation"}},d={},c=[{value:"SQL",id:"sql",level:2},{value:"Basic usage",id:"basic-usage",level:3},{value:"Common Expression Language (CEL)",id:"common-expression-language-cel",level:2},{value:"JsonLogic",id:"jsonlogic",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Lists as arrays",id:"lists-as-arrays",level:3},{value:"Independent combinators",id:"independent-combinators",level:3},{value:"Fields as value source",id:"fields-as-value-source",level:3}];function h(e){const n=Object.assign({h2:"h2",p:"p",code:"code",pre:"pre",a:"a",h3:"h3",em:"em",admonition:"admonition"},(0,i.a)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.ZP,{}),"\n",(0,t.jsx)(n.h2,{id:"sql",children:"SQL"}),"\n",(0,t.jsxs)(n.p,{children:["Use the ",(0,t.jsx)(n.code,{children:"parseSQL"})," function to convert SQL ",(0,t.jsx)(n.code,{children:"SELECT"})," statements into a format suitable for the ",(0,t.jsx)(n.code,{children:"<QueryBuilder />"})," component's ",(0,t.jsx)(n.code,{children:"query"})," prop. The function signature is:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function parseSQL(sql: string, options?: ParseSQLOptions): RuleGroupTypeAny;\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"parseSQL"})," takes a SQL ",(0,t.jsx)(n.code,{children:"SELECT"})," statement (either the full statement or the ",(0,t.jsx)(n.code,{children:"WHERE"})," clause by itself). Try it out in the ",(0,t.jsx)(n.a,{href:"/demo",children:"demo"}),' by clicking the "Load from SQL" button.']}),"\n",(0,t.jsxs)(n.p,{children:["The optional second parameter to ",(0,t.jsx)(n.code,{children:"parseSQL"})," is an options object that configures how the function handles named or anonymous bind variables within the SQL string."]}),"\n",(0,t.jsxs)(n.p,{children:['Click the "Import SQL" button in ',(0,t.jsx)(n.a,{href:"/demo",children:"the demo"})," to try it out."]}),"\n",(0,t.jsx)(n.h3,{id:"basic-usage",children:"Basic usage"}),"\n",(0,t.jsx)(n.p,{children:"Running any of the following statements will produce the same result (see below):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"parseSQL(`SELECT * FROM t WHERE firstName = 'Steve' AND lastName = 'Vai'`);\n\nparseSQL(`SELECT * FROM t WHERE firstName = ? AND lastName = ?`, {\n  params: ['Steve', 'Vai'],\n});\n\nparseSQL(`SELECT * FROM t WHERE firstName = :p1 AND lastName = :p2`, {\n  params: { p1: 'Steve', p2: 'Vai' },\n});\n\nparseSQL(`SELECT * FROM t WHERE firstName = $p1 AND lastName = $p2`, {\n  params: { p1: 'Steve', p2: 'Vai' },\n  paramPrefix: '$',\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Output (",(0,t.jsx)(n.code,{children:"RuleGroupType"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "combinator": "and",\n  "rules": [\n    {\n      "field": "firstName",\n      "operator": "=",\n      "value": "Steve"\n    },\n    {\n      "field": "lastName",\n      "operator": "=",\n      "value": "Vai"\n    }\n  ]\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"common-expression-language-cel",children:"Common Expression Language (CEL)"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"parseCEL"})," takes a ",(0,t.jsx)(n.a,{href:"https://github.com/google/cel-spec",children:"CEL"})," string and converts it to ",(0,t.jsx)(n.code,{children:"RuleGroupType"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:['Click the "Import CEL" button in ',(0,t.jsx)(n.a,{href:"/demo",children:"the demo"})," to try it out."]}),"\n",(0,t.jsx)(n.h2,{id:"jsonlogic",children:"JsonLogic"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"parseJsonLogic"})," takes a ",(0,t.jsx)(n.a,{href:"https://jsonlogic.com/",children:"JsonLogic"})," object and converts it to ",(0,t.jsx)(n.code,{children:"RuleGroupType"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:['Click the "Import JsonLogic" button in ',(0,t.jsx)(n.a,{href:"/demo",children:"the demo"})," to try it out."]}),"\n",(0,t.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsx)(n.h3,{id:"lists-as-arrays",children:"Lists as arrays"}),"\n",(0,t.jsxs)(n.p,{children:["To generate actual arrays instead of comma-separated strings for lists of values following ",(0,t.jsx)(n.code,{children:"IN"})," and ",(0,t.jsx)(n.code,{children:"BETWEEN"})," operators, use the ",(0,t.jsx)(n.code,{children:"listsAsArrays"})," option."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"parseSQL(`SELECT * FROM t WHERE lastName IN ('Vai', 'Vaughan') AND age BETWEEN 20 AND 100`, {\n  listsAsArrays: true;\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "combinator": "and",\n  "rules": [\n    {\n      "field": "lastName",\n      "operator": "in",\n      "value": ["Vai", "Vaughan"]\n    },\n    {\n      "field": "age",\n      "operator": "between",\n      "value": [20, 100]\n    }\n  ]\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"independent-combinators",children:"Independent combinators"}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.code,{children:"independentCombinators"})," option is ",(0,t.jsx)(n.code,{children:"true"}),", ",(0,t.jsx)(n.code,{children:"parse*"})," functions will output a query with combinator identifiers between sibling rules/groups."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"parseSQL(`SELECT * FROM t WHERE firstName = 'Steve' AND lastName = 'Vai'`, {\n  independentCombinators: true,\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Output (",(0,t.jsx)(n.code,{children:"RuleGroupTypeIC"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "rules": [\n    {\n      "field": "firstName",\n      "operator": "=",\n      "value": "Steve"\n    },\n    "and",\n    {\n      "field": "lastName",\n      "operator": "=",\n      "value": "Vai"\n    }\n  ]\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"fields-as-value-source",children:"Fields as value source"}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.code,{children:"fields"})," option (which accepts the same types as the ",(0,t.jsxs)(n.a,{href:"./querybuilder#fields",children:[(0,t.jsx)(n.code,{children:"fields"})," prop"]}),") is provided, and ",(0,t.jsx)(n.em,{children:"only"})," if it is provided, then ",(0,t.jsx)(n.code,{children:"parse*"})," functions will validate clauses that have a field identifier to the right of the operator instead of a primitive value. A ",(0,t.jsx)(n.code,{children:"getValueSources"})," function (with the same signature as the ",(0,t.jsx)(n.a,{href:"./querybuilder#getvaluesources",children:"prop of the same name"}),") can also be provided to help validate rules."]}),"\n",(0,t.jsxs)(n.p,{children:['In order for such a rule to be considered valid, one of the following must be an array that includes the string "field": 1) the ',(0,t.jsx)(n.code,{children:"getValueSources"})," return value, 2) the field's ",(0,t.jsx)(n.code,{children:"valueSources"})," property return value, or 3) the field's ",(0,t.jsx)(n.code,{children:"valueSources"})," property itself."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"parseSQL(`SELECT * FROM t WHERE firstName = lastName`, {\n  fields: [\n    { name: 'firstName', label: 'First Name' },\n    { name: 'lastName', label: 'Last Name' },\n  ],\n  getValueSources: () => ['value', 'field'],\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Output:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "combinator": "and",\n  "rules": [\n    {\n      "field": "firstName",\n      "operator": "=",\n      "value": "lastName",\n      "valueSource": "field"\n    }\n  ]\n}\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"parse*"}),' functions will only validate clauses where "field" is the ',(0,t.jsx)(n.em,{children:"only"}),' value source. Operators that take multiple values, like "between" and "in", must only have field names to the right of the operator, not a mix of field names and primitive values.']})})]})}const u=function(e={}){const{wrapper:n}=Object.assign({},(0,i.a)(),e.components);return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(h,e)})):h(e)}},71670:(e,n,s)=>{s.d(n,{a:()=>a});var t=s(27378);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}}}]);