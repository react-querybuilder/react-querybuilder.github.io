"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[28623],{53903:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>d,toc:()=>u});var t=i(62540),o=i(65404),s=i(4830),r=i(19026);const a={title:"Maximizing rendering performance",description:"How to avoid common pitfalls for a smoother user experience",hide_table_of_contents:!0},l=void 0,d={id:"tips/maximizing-performance",title:"Maximizing rendering performance",description:"How to avoid common pitfalls for a smoother user experience",source:"@site/versioned_docs/version-7/tips/maximizing-performance.mdx",sourceDirName:"tips",slug:"/tips/maximizing-performance",permalink:"/docs/tips/maximizing-performance",draft:!1,unlisted:!1,editUrl:"https://github.com/react-querybuilder/react-querybuilder/edit/main/website/versioned_docs/version-7/tips/maximizing-performance.mdx",tags:[],version:"7",frontMatter:{title:"Maximizing rendering performance",description:"How to avoid common pitfalls for a smoother user experience",hide_table_of_contents:!0},sidebar:"mySidebar",previous:{title:"Working with option lists",permalink:"/docs/tips/option-lists"},next:{title:"Managing operators",permalink:"/docs/tips/managing-operators"}},c={},u=[{value:"Avoiding common pitfalls",id:"avoiding-common-pitfalls",level:2},{value:"Exceptions",id:"exceptions",level:2},{value:"Examples",id:"examples",level:2},{value:"&quot;Bad&quot; example",id:"bad-example",level:3},{value:"&quot;Good&quot; example",id:"good-example",level:3}];function p(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Refer to the ",(0,t.jsx)(n.a,{href:"../typescript",children:"TypeScript reference"})," page for information about the types and interfaces referenced below."]})}),"\n"]})}),"\n",(0,t.jsx)(n.admonition,{title:"TL;DR",type:"tip",children:(0,t.jsxs)(n.p,{children:["Each prop passed to ",(0,t.jsx)(n.code,{children:"QueryBuilder"})," should have a stable reference or be memoized."]})}),"\n",(0,t.jsxs)(n.p,{children:["As of version 7, all ",(0,t.jsx)(n.code,{children:"QueryBuilder"})," props, components, and derived values are aggressively memoized with ",(0,t.jsx)(n.code,{children:"React.memo"}),", ",(0,t.jsx)(n.code,{children:"useMemo"}),", ",(0,t.jsx)(n.code,{children:"useCallback"}),", and immutability tools like ",(0,t.jsx)(n.a,{href:"https://immerjs.github.io/immer/",children:(0,t.jsx)(n.code,{children:"immer"})}),". This can noticeably improve rendering performance for large queries, especially when using certain style libraries. To take advantage of these optimizations, ",(0,t.jsx)(n.em,{children:"every"})," prop passed to ",(0,t.jsx)(n.code,{children:"QueryBuilder"})," (except ",(0,t.jsx)(n.code,{children:"query"}),", if used) must have a stable reference or at least be memoized. For related reasons, we encourage the use of ",(0,t.jsx)(n.code,{children:"QueryBuilder"})," as an uncontrolled component (assign ",(0,t.jsx)(n.code,{children:"defaultQuery"})," instead of ",(0,t.jsx)(n.code,{children:"query"}),")."]}),"\n",(0,t.jsx)(n.h2,{id:"avoiding-common-pitfalls",children:"Avoiding common pitfalls"}),"\n",(0,t.jsxs)(n.p,{children:["You can avoid unstable references by defining unchanging props, including object, array, and function definitions, outside the component rendering function. This commonly includes the ",(0,t.jsx)(n.code,{children:"fields"})," array and ",(0,t.jsx)(n.code,{children:"onQueryChange"})," callback. For props that ",(0,t.jsx)(n.em,{children:"must"})," be defined inside the component, memoize them with ",(0,t.jsx)(n.code,{children:"useMemo"})," or ",(0,t.jsx)(n.code,{children:"useCallback"}),". In particular, avoid defining non-primitive props inline in the JSX."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("span",{style:{color:"green",fontWeight:"bold"},children:"\u2713 DO"})," define variables that will remain unchanged outside the component if possible."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("span",{style:{color:"green",fontWeight:"bold"},children:"\u2713 DO"})," memoize objects, arrays, and other values that must be created and/or calculated within the component with ",(0,t.jsx)(n.code,{children:"useMemo"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("span",{style:{color:"green",fontWeight:"bold"},children:"\u2713 DO"})," memoize functions that must be created within the component with ",(0,t.jsx)(n.code,{children:"useCallback"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("span",{style:{color:"red",fontWeight:"bold"},children:"\u26a0 DO NOT"})," define objects, arrays, or functions inline in the JSX prop declarations.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["This includes subcomponents\u2014see ",(0,t.jsx)(n.a,{href:"./common-mistakes#custom-component-as-closure",children:"Custom component as closure"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Inline assignment of primitives like strings, numbers, and booleans is usually not a problem."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"exceptions",children:"Exceptions"}),"\n",(0,t.jsxs)(n.p,{children:["Some props implement more granular memoization. Internally, ",(0,t.jsx)(n.code,{children:"QueryBuilder"})," individually memoizes each property of the objects passed to these props:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"controlClassnames"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"controlElements"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"translations"})," (even nested properties are memoized individually for ",(0,t.jsx)(n.code,{children:"translations"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.h3,{id:"bad-example",children:'"Bad" example'}),"\n",(0,t.jsxs)(n.p,{children:["These patterns can be detrimental to the overall performance of ",(0,t.jsx)(n.code,{children:"QueryBuilder"}),"."]}),"\n",(0,t.jsx)(s.A,{type:"danger",title:"",icon:(0,t.jsx)(r.A,{}),children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"function App() {\n  const { t } = useTranslation(); // (<-- third-party i18n library)\n  // \u26a0 Even though this `useState` call only sets the initial `query` value once, the object\n  // itself is still created on every render. This doesn't affect the stability of the reference,\n  // but it's probably a good idea to define the object outside the component anyway.\n  const [query, setQuery] = useState({ combinator: 'and', rules: [] });\n\n  // \u274c This function is not memoized and will get recreated on each render.\n  const getOperators = (field: Field) => t(defaultOperators);\n\n  return (\n    <QueryBuilder\n      // \u26a0 As a controlled component with potential for updates (not disabled), an unstable\n      // reference to `query` is unavoidable. This is generally not a problem, but using\n      // `defaultQuery` instead of `query` could avoid the issue entirely.\n      query={query}\n      //\n      // \u274c Inline function definition. Also see note below about `useState`/`useReducer`.\n      onQueryChange={q => setQuery(q)}\n      //\n      // \u274c Inline definition of an array that doesn't change over time.\n      fields={[\n        { name: 'firstName', label: 'First Name' },\n        { name: 'lastName', label: 'Last Name' },\n      ]}\n      //\n      // This function is not defined inline in the JSX, but it does not have a stable\n      // reference since it's recreated on each render (see its declaration above).\n      getOperators={getOperators}\n      //\n      controlElements={{\n        // \u274c Component function is defined inline and will be recreated during each render.\n        // This can also cause bugs like \"input loses focus after each keystroke.\"\n        actionElement: props => <button onClick={props.handleOnClick}>{props.label}</button>,\n      }}\n    />\n  );\n}\n"})})}),"\n",(0,t.jsx)(n.h3,{id:"good-example",children:'"Good" example'}),"\n",(0,t.jsxs)(n.p,{children:["Follow the patterns in this example to get the best performance from ",(0,t.jsx)(n.code,{children:"QueryBuilder"}),"."]}),"\n",(0,t.jsx)(s.A,{type:"tip",title:"",icon:"\u2713",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"// \u2705 Fields array that never changes defined outside the component.\nconst fields: Field[] = [\n  { name: 'firstName', label: 'First Name' },\n  { name: 'lastName', label: 'Last Name' },\n];\n\n// \u2705 Custom subcomponent defined outside the main component render function.\nconst MyActionElement = (props: ActionProps) => (\n  <button onClick={props.handleOnClick}>{props.label}</button>\n);\n\n// \u2705 Default query, which is only access once, defined outside the component.\nconst defaultQuery: RuleGroupType = { combinator: 'and', rules: [] };\n\nfunction App() {\n  const { t } = useTranslation(); // (<-- third-party i18n library)\n  // \u2705 `useState` parameter (the initial value of `query`) defined outside the component.\n  const [query, setQuery] = useState(defaultQuery);\n\n  // \u2705 Function defined inside the component memoized with `useCallback`. Since `t`\n  // _probably_ has a stable reference, this function will rarely, if ever, be recreated.\n  const getOperators = useCallback((field: Field) => t(defaultOperators), [t]);\n\n  return (\n    <QueryBuilder\n      // \u2705 The value passed to `defaultQuery` is only used once, so the stability of\n      // its reference is unimportant.\n      defaultQuery={query}\n      //\n      // \u2705 `useState` setters and `useReducer` dispatchers always have stable references.\n      onQueryChange={setQuery}\n      //\n      // \u2705 `fields` array defined outside the component.\n      fields={fields}\n      //\n      // \u2705 Function memoized with `useCallback`.\n      getOperators={getOperators}\n      //\n      // See \"Exceptions\" section above regarding the following props.\n      controlElements={{\n        // \u2705 Subcomponent defined outside the current component.\n        actionElement: MyActionElement,\n      }}\n      // \u2705 `translations` is memoized down to the sub-property level.\n      translations={{\n        addGroup: {\n          label: 'Add Group',\n        },\n        addRule: {\n          label: 'Add Rule',\n        },\n      }}\n    />\n  );\n}\n"})})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}}}]);