"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1633],{70992:(e,t,n)=>{n.d(t,{c:()=>a});var r=n(42349),o=n(44561),i=n(27378),s=n(24246);const a=e=>{let{children:t,customSetup:n,options:a,rqbVersion:l=6}=e;const d="dark"===(0,o.I)().colorMode,c=i.Children.toArray(t),u=d?"#343a46":"#ffffff";let h=!0;const p={};for(const r of c){const{props:e}=r.props.children;let t,n=!1,o=!1;if(e.metastring){const[r,...i]=e.metastring.split(" ");t="/"+r,n=i.includes("hidden"),o=i.includes("active")}else if("language-tsx"===e.className)t="/App.tsx";else if("language-js"===e.className)t="/App.js";else{if("language-css"!==e.className)throw new Error(`Code block is missing a filename: ${e.children}`);t="/styles.css"}if(p[t])throw new Error(`File ${t} was defined multiple times. Each file snippet should have a unique path name.`);"/styles.css"!==t||n||(h=!1),p[t]={code:e.children,hidden:n,active:o}}const f=RegExp("^import +'react-querybuilder/dist/query-builder\\.s?css';?$").test(p["/App.tsx"]?.code)?"":"@import 'react-querybuilder/dist/query-builder.css';",m=`\nbody {\n  background-color: ${u};\n}\npre {\n  padding: 1rem;\n  background-color: white;\n  border: 1px solid lightgray;\n  border-radius: 0.25rem;\n  white-space: pre-wrap;\n}\n${d?"\nh1, h2, h3, h4, h5, h6 {\n  color: white;\n}":""}`;p["/styles.css"]={code:[f,m,p["/styles.css"]?.code??""].join("\n\n"),hidden:h};const x=4===l?{"react-querybuilder":"^4.5.3"}:5===l?{"@react-querybuilder/dnd":"^5.4.1","react-querybuilder":"^5.4.1"}:{"@react-querybuilder/dnd":"^6.0.7","react-querybuilder":"^6.0.7"},y={...n,dependencies:{...n?.dependencies,...x}};return(0,s.jsx)("div",{className:"sandpackrqb",children:(0,s.jsx)(r.xR,{files:p,theme:d?"dark":void 0,template:"vite-react-ts",customSetup:y,options:a})},`v${l}`)}},91350:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var r=n(24246),o=n(71670),i=n(70992);const s={title:"Path concepts",description:'Explanation of the "path" property of rules and groups',hide_table_of_contents:!0},a=void 0,l={id:"tips/path",title:"Path concepts",description:'Explanation of the "path" property of rules and groups',source:"@site/docs/tips/path.mdx",sourceDirName:"tips",slug:"/tips/path",permalink:"/docs/next/tips/path",draft:!1,unlisted:!1,editUrl:"https://github.com/react-querybuilder/react-querybuilder/edit/main/website/docs/tips/path.mdx",tags:[],version:"current",frontMatter:{title:"Path concepts",description:'Explanation of the "path" property of rules and groups',hide_table_of_contents:!0},sidebar:"mySidebar",previous:{title:"Managing operators",permalink:"/docs/next/tips/managing-operators"},next:{title:"Limit rule groups",permalink:"/docs/next/tips/limit-groups"}},d={},c=[{value:"Finding a <code>path</code>",id:"finding-a-path",level:2},{value:"Example",id:"example",level:2}];function u(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["While the ",(0,r.jsx)(t.code,{children:"id"})," property can uniquely identify a rule or group, an ",(0,r.jsx)(t.code,{children:"id"})," won't naturally indicate anything about the ",(0,r.jsx)(t.em,{children:"position"}),' of the object within the query hierarchy. For that reason, React Query Builder uses the concept of a "path" to locate and update query objects.']}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"path"})," property is an array of integers unique to each rule and group within a query. The query object itself (the root group) has a ",(0,r.jsx)(t.code,{children:"path"})," of ",(0,r.jsx)(t.code,{children:"[]"}),". All other rules and groups within the query have a ",(0,r.jsx)(t.code,{children:"path"})," that corresponds to their position within the ",(0,r.jsx)(t.code,{children:"rules"})," array(s) of their ancestor group(s)."]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"path"})," of any object (rule or group) is equivalent to the ",(0,r.jsx)(t.code,{children:"path"})," of its parent group, with the index of the object within its parent's ",(0,r.jsx)(t.code,{children:"rules"})," array pushed onto the end. You can think of it like this: ",(0,r.jsx)(t.code,{children:"path = [...parentPath, index]"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Consider the following query. The respective ",(0,r.jsx)(t.code,{children:"path"})," for each rule and group is commented above it, along with a short explanation."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"// [] (the root group)\nconst query: RuleGroupType = {\n  combinator: 'and',\n  rules: [\n    // [0] (the first, aka zeroth, element in the root rules array)\n    { field: 'f1', operator: '=', value: 'v1' },\n    // [1] (the second element in the root rules array is a sub-group)\n    {\n      combinator: 'or',\n      rules: [\n        // [1, 0] (the first element within the rules array\n        //         of the group occupying the second position\n        //         in the root rules array)\n        { field: 'f2', operator: '=', value: 'v2' },\n        // [1, 1] (the second element within the rules array\n        //         of the group occupying the second position\n        //         in the root rules array)\n        { field: 'f3', operator: '=', value: 'v3' },\n      ],\n    },\n  ],\n};\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"path"})," of the top-most rule in the query is ",(0,r.jsx)(t.code,{children:"[0]"}),", ",(0,r.jsx)(t.code,{children:"0"})," being the index of that rule within the root group's ",(0,r.jsx)(t.code,{children:"rules"})," array. The ",(0,r.jsx)(t.code,{children:"path"})," of the first sub-group in the query is ",(0,r.jsx)(t.code,{children:"[1]"}),", again according to its index within the outermost ",(0,r.jsx)(t.code,{children:"rules"})," array. Each child rule of ",(0,r.jsx)(t.em,{children:"that"})," group has a path that begins with ",(0,r.jsx)(t.code,{children:"1"})," (the ",(0,r.jsx)(t.code,{children:"path"})," of its parent), followed by its own index."]}),"\n",(0,r.jsxs)(t.h2,{id:"finding-a-path",children:["Finding a ",(0,r.jsx)(t.code,{children:"path"})]}),"\n",(0,r.jsxs)(t.p,{children:["Use the ",(0,r.jsx)(t.a,{href:"../utils/misc#findpath",children:(0,r.jsx)(t.code,{children:"findPath"})})," function to locate a specific rule or group for examination or update. Given the query above:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"findPath([1, 0], query);\n"})}),"\n",(0,r.jsx)(t.p,{children:"would return this object:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-json",children:'{ "field": "f2", "operator": "=", "value": "v2" }\n'})}),"\n",(0,r.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(t.p,{children:["In most scenarios you won't need to interact with the ",(0,r.jsx)(t.code,{children:"path"})," attribute, but it can come in handy in certain situations. One such situation is if you need to access other parts of the query from within a custom component."]}),"\n",(0,r.jsxs)(t.p,{children:["Say you have a custom value editor that needs to know the ",(0,r.jsx)(t.code,{children:"value"})," of each of its sibling rules. You can get the full query object using the ",(0,r.jsx)(t.code,{children:"useQueryBuilderSelector"})," hook (which connects to React Query Builder's custom Redux implementation). You can then retrieve the sibling rules with a combination of ",(0,r.jsx)(t.code,{children:"getParentPath"})," and ",(0,r.jsx)(t.code,{children:"findPath"}),"."]}),"\n",(0,r.jsxs)(t.admonition,{type:"info",children:[(0,r.jsxs)(t.p,{children:["Prior to version 7, custom components only received props relevant to the rule or group they acted on. You could augment these default props with other data or information--the root query object, for example--by using the ",(0,r.jsxs)(t.a,{href:"../components/querybuilder#context",children:[(0,r.jsx)(t.code,{children:"context"})," prop"]}),"."]}),(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"context"})," prop is still available, but is not necessary for retrieving the query."]})]}),"\n",(0,r.jsxs)(i.c,{rqbVersion:6,options:{editorHeight:444,activeFile:"/CustomValueEditor.tsx"},children:[(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:"CustomValueEditor.tsx",children:"import {\n  RuleGroupType,\n  RuleType,\n  ValueEditor,\n  ValueEditorProps,\n  findPath,\n  getParentPath,\n  getQuerySelectorById,\n  useQueryBuilderSelector,\n} from 'react-querybuilder';\n\nexport const CustomValueEditor = (props: ValueEditorProps) => {\n  // Get the full query object\n  const query = useQueryBuilderSelector(getQuerySelectorById(props.schema.qbId));\n  // Get the path of this rule's parent group\n  const parentPath = getParentPath(props.path);\n  // Find the parent group object in the query\n  const parentGroup = findPath(parentPath, query) as RuleGroupType;\n  const id = findPath(props.path, query)!.id;\n  // Get a comma-separated list of all sibling rule values\n  const siblingValues = (\n    parentGroup.rules.filter(\n      r =>\n        // filter out groups\n        !('rules' in r) &&\n        // filter out self\n        r.id !== id\n    ) as RuleType[]\n  )\n    // map the `value` property\n    .map(r => r.value)\n    // join with comma\n    .join(', ');\n\n  return (\n    <div style={{ display: 'flex', flexDirection: 'column' }}>\n      <ValueEditor {...props} />\n      <span>Others: {siblingValues}</span>\n    </div>\n  );\n};\n"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:"import { useState } from 'react';\nimport { QueryBuilder } from 'react-querybuilder';\nimport { CustomValueEditor } from './CustomValueEditor';\nimport { defaultQuery, fields, operators } from './constants';\n\nexport default function App() {\n  const [query, setQuery] = useState(defaultQuery);\n\n  return (\n    <QueryBuilder\n      fields={fields}\n      operators={operators}\n      query={query}\n      onQueryChange={setQuery}\n      controlElements={{ valueEditor: CustomValueEditor }}\n    />\n  );\n}\n"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:"constants.ts",children:"import { defaultOperators, Field, RuleGroupType } from 'react-querybuilder';\n\nexport const operators = defaultOperators.filter(op => op.name === '=');\n\nexport const fields: Field[] = [\n  { name: 'field1', label: 'Field 1' },\n  { name: 'field2', label: 'Field 2' },\n  { name: 'field3', label: 'Field 3' },\n  { name: 'field4', label: 'Field 4' },\n];\n\nexport const defaultQuery: RuleGroupType = {\n  combinator: 'and',\n  rules: [\n    { field: 'field1', operator: '=', value: '1' },\n    { field: 'field2', operator: '=', value: '2' },\n    { field: 'field3', operator: '=', value: '3' },\n    { field: 'field4', operator: '=', value: '4' },\n  ],\n};\n"})}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-css",children:".queryBuilder .rule {\n  align-items: flex-start;\n}\n\nspan {\n  color: gray;\n}\n"})})]})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);