"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[58619],{42068:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var t=i(62540),r=i(65404);const o={title:"Maximizing performance",description:"How to avoid common pitfalls for a smoother experience"},s=void 0,a={id:"tips/maximizing-performance",title:"Maximizing performance",description:"How to avoid common pitfalls for a smoother experience",source:"@site/docs/tips/maximizing-performance.mdx",sourceDirName:"tips",slug:"/tips/maximizing-performance",permalink:"/docs/next/tips/maximizing-performance",draft:!1,unlisted:!1,editUrl:"https://github.com/react-querybuilder/react-querybuilder/edit/main/website/docs/tips/maximizing-performance.mdx",tags:[],version:"current",frontMatter:{title:"Maximizing performance",description:"How to avoid common pitfalls for a smoother experience"},sidebar:"mySidebar",previous:{title:"Working with option lists",permalink:"/docs/next/tips/option-lists"},next:{title:"Managing operators",permalink:"/docs/next/tips/managing-operators"}},l={},c=[{value:"Avoiding common pitfalls",id:"avoiding-common-pitfalls",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Refer to the ",(0,t.jsx)(n.a,{href:"../typescript",children:"TypeScript reference"})," page for information about the types and interfaces referenced below."]})}),"\n"]})}),"\n",(0,t.jsx)(n.admonition,{title:"TL;DR",type:"tip",children:(0,t.jsxs)(n.p,{children:["Each prop passed to ",(0,t.jsx)(n.code,{children:"QueryBuilder"})," should have a stable reference or be memoized."]})}),"\n",(0,t.jsxs)(n.p,{children:["As of version 7, all ",(0,t.jsx)(n.code,{children:"QueryBuilder"})," props, components, and derived values are aggressively memoized with ",(0,t.jsx)(n.code,{children:"React.memo"}),", ",(0,t.jsx)(n.code,{children:"useMemo"}),", ",(0,t.jsx)(n.code,{children:"useCallback"}),", and immutability tools including ",(0,t.jsx)(n.a,{href:"https://immerjs.github.io/immer/",children:(0,t.jsx)(n.code,{children:"immer"})}),". This can noticeably improve rendering performance for large queries, especially when using certain style libraries. To take advantage of these optimizations, ",(0,t.jsx)(n.em,{children:"every"})," prop passed to ",(0,t.jsx)(n.code,{children:"QueryBuilder"})," (except ",(0,t.jsx)(n.code,{children:"query"}),", if used) must have a stable reference or at least be memoized. For related reasons, we encourage using ",(0,t.jsx)(n.code,{children:"QueryBuilder"})," as an uncontrolled component by specifying ",(0,t.jsx)(n.code,{children:"defaultQuery"})," instead of ",(0,t.jsx)(n.code,{children:"query"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"avoiding-common-pitfalls",children:"Avoiding common pitfalls"}),"\n",(0,t.jsxs)(n.p,{children:["You can avoid unstable references by moving unchanging props, including object, array, and function definitions, outside the component rendering function. This commonly includes the ",(0,t.jsx)(n.code,{children:"fields"})," array and ",(0,t.jsx)(n.code,{children:"onQueryChange"})," callback. For props that ",(0,t.jsx)(n.em,{children:"must"})," be defined inside the component, memoize them with ",(0,t.jsx)(n.code,{children:"useMemo"})," or ",(0,t.jsx)(n.code,{children:"useCallback"}),". In particular, avoid defining props inline in the JSX."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("span",{style:{color:"green",fontWeight:"bold"},children:"DO"})," define variables that will remain\nunchanged outside the component if possible."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("span",{style:{color:"green",fontWeight:"bold"},children:"DO"})," memoize objects, arrays, and other\nvalues that must be created and/or calculated within the component with ",(0,t.jsx)(n.code,{children:"useMemo"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("span",{style:{color:"green",fontWeight:"bold"},children:"DO"})," memoize functions that must be\ncreated within the component with ",(0,t.jsx)(n.code,{children:"useCallback"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)("span",{style:{color:"red",fontWeight:"bold"},children:"DO NOT"})," define objects, arrays, or\nfunctions inside the JSX prop declarations (primitives like strings, numbers, and booleans are\nusually OK, though)."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:'"Bad" example \u274c',type:"danger",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"function App() {\n  const { t } = useTranslation(); // (<-- third-party i18n library)\n  const [query, setQuery] = useState();\n\n  // This function gets recreated on each render.\n  const getOperators = (field: Field) => t(defaultOperators);\n\n  return (\n    <QueryBuilder\n      // Avoid inline function definitions. Also see note below about `useState`/`useReducer`.\n      onQueryChange={q => setQuery(q)}\n      // Avoid inline array definitions, especially when the array will never change.\n      fields={[\n        { name: 'firstName', label: 'First Name' },\n        { name: 'lastName', label: 'Last Name' },\n      ]}\n      // This function is not defined inline, but it still does not have a stable reference.\n      getOperators={getOperators}\n    />\n  );\n}\n"})})}),"\n",(0,t.jsx)(n.admonition,{title:'"Good" example \u2705',type:"tip",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"// The fields array never changes, so it can be defined outside the component.\nconst fields: Field[] = [\n  { name: 'firstName', label: 'First Name' },\n  { name: 'lastName', label: 'Last Name' },\n];\n\nfunction App() {\n  const { t } = useTranslation(); // (<-- third-party i18n library)\n  const [query, setQuery] = useState();\n\n  // Memoize functions with `useCallback`. Since `t` (probably) has a\n  // stable reference, this function will rarely (if ever) be recreated.\n  const getOperators = useCallback((field: Field) => t(defaultOperators), [t]);\n\n  return (\n    <QueryBuilder\n      // React `useState`/`useReducer` setters always have a stable reference.\n      onQueryChange={setQuery}\n      // This array is defined outside the component and therefore has a stable reference.\n      fields={fields}\n      // This function is memoized with `useCallback` and therefore has a stable reference.\n      getOperators={getOperators}\n    />\n  );\n}\n"})})})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},65404:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var t=i(63696);const r={},o=t.createContext(r);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);