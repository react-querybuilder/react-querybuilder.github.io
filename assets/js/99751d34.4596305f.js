"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[68967],{9881:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var i=t(62540),o=t(65404),r=(t(41485),t(18597));const s={title:"Working with option lists",description:"Managing ambiguity in option list types"},l=void 0,a={id:"tips/option-lists",title:"Working with option lists",description:"Managing ambiguity in option list types",source:"@site/docs/tips/option-lists.mdx",sourceDirName:"tips",slug:"/tips/option-lists",permalink:"/docs/next/tips/option-lists",draft:!1,unlisted:!1,editUrl:"https://github.com/react-querybuilder/react-querybuilder/edit/main/website/docs/tips/option-lists.mdx",tags:[],version:"current",frontMatter:{title:"Working with option lists",description:"Managing ambiguity in option list types"},sidebar:"mySidebar",previous:{title:"Customization showcase",permalink:"/docs/next/tips/showcase"},next:{title:"Maximizing rendering performance",permalink:"/docs/next/tips/maximizing-performance"}},c={},d=[{value:"An incorrect assumption",id:"an-incorrect-assumption",level:2},{value:"Workarounds",id:"workarounds",level:2},{value:"Utilities",id:"utilities",level:2},{value:"<code>getOption</code>",id:"getoption",level:3},{value:"Examples",id:"examples",level:4},{value:"<code>getFirstOption</code>",id:"getfirstoption",level:3},{value:"Examples",id:"examples-1",level:4},{value:"<code>toOptions</code>",id:"tooptions",level:3},{value:"Usage",id:"usage",level:4},{value:"<code>Option[]</code> example",id:"option-example",level:4},{value:"<code>OptionGroup[]</code> example",id:"optiongroup-example",level:4},{value:"<code>toFlatOptionArray</code>",id:"toflatoptionarray",level:3},{value:"<code>isOptionGroupArray</code>",id:"isoptiongrouparray",level:3},{value:"<code>uniqOptList</code>",id:"uniqoptlist",level:3},{value:"<code>uniqByIdentifier</code>",id:"uniqbyidentifier",level:3}];function p(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Refer to the ",(0,i.jsx)(n.a,{href:"../typescript",children:"TypeScript reference"})," page for information about the types and interfaces referenced below."]})}),"\n"]})}),"\n",(0,i.jsxs)(n.p,{children:["Option list props in React Query Builder like ",(0,i.jsx)(n.a,{href:"../components/querybuilder#fields",children:(0,i.jsx)(n.code,{children:"fields"})}),", ",(0,i.jsx)(n.a,{href:"../components/querybuilder#combinators",children:(0,i.jsx)(n.code,{children:"combinators"})}),", and ",(0,i.jsx)(n.a,{href:"../components/querybuilder#operators",children:(0,i.jsx)(n.code,{children:"operators"})}),", are based on the type ",(0,i.jsx)(n.a,{href:"../typescript#option-lists",children:(0,i.jsx)(n.code,{children:"OptionList"})}),". ",(0,i.jsx)(n.code,{children:"OptionList"})," is a union type allowing two different types of arrays: ",(0,i.jsx)(n.code,{children:"Option[]"})," and ",(0,i.jsx)(n.code,{children:"OptionGroup[]"}),". This is a flexible design, but it adds some complexity to the consumption of option list-type props in custom subcomponents."]}),"\n",(0,i.jsx)(n.p,{children:"This page provides tips to help manage the inherent ambiguity of option list TypeScript types."}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Option"})," objects have ",(0,i.jsx)(n.code,{children:"label"}),", ",(0,i.jsx)(n.code,{children:"name"}),", and ",(0,i.jsx)(n.code,{children:"value"})," properties, all of which extend ",(0,i.jsx)(n.code,{children:"string"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"OptionGroup"})," objects have a ",(0,i.jsx)(n.code,{children:"label"})," property along with an ",(0,i.jsx)(n.code,{children:"options"})," property which is an array of ",(0,i.jsx)(n.code,{children:"Option"})," objects."]}),"\n"]}),(0,i.jsxs)(n.p,{children:["This structure is similar to the ",(0,i.jsx)(n.code,{children:"children"})," prop on a ",(0,i.jsx)(n.code,{children:"<select>"})," element, which can be an array of ",(0,i.jsx)(n.code,{children:"<option>"})," elements or an array of ",(0,i.jsx)(n.code,{children:"<optgroup>"})," elements that each contain its own nested ",(0,i.jsx)(n.code,{children:"<option>"})," list."]})]}),"\n",(0,i.jsx)(n.h2,{id:"an-incorrect-assumption",children:"An incorrect assumption"}),"\n",(0,i.jsx)(n.p,{children:"You may have found this page after seeing a TypeScript error message similar to this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Property 'name' does not exist on type 'FullOption<string> | OptionGroup<FullOption<string>>'.\n  Property 'name' does not exist on type 'OptionGroup<FullOption<string>>'. ts(2339)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This generally happens when you treat elements in the option list as if they were definitely ",(0,i.jsx)(n.code,{children:"Option"})," types. For example, mapping through the list to get the ",(0,i.jsx)(n.code,{children:"name"})," property, like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const ListAllOptionNames = (props: ValueSelectorProps) => {\n  return <div>{props.options.map(opt => opt.name).join(', ')}</div>;\n  //                                        ^^^^ error\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It's natural to assume that an option list passed in to ",(0,i.jsx)(n.code,{children:"QueryBuilder"})," as an ",(0,i.jsx)(n.code,{children:"Option[]"})," would ",(0,i.jsx)(n.em,{children:"still"})," be an ",(0,i.jsx)(n.code,{children:"Option[]"})," when it gets to the subcomponent. However, React Query Builder's type generics only infer the type of the options within the list, not the type of the list itself."]}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["All options in list-type props passed to subcomponents are guaranteed to include both ",(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"value"})," properties, even if they don't include one or the other in their original form on the corresponding ",(0,i.jsx)(n.code,{children:"QueryBuilder"})," prop."]}),(0,i.jsxs)(n.p,{children:["As an example, consider this ",(0,i.jsx)(n.code,{children:"fields"})," array:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const fields: Field[] = [\n  { name: 'firstName', label: 'First Name' },\n  { name: 'lastName', label: 'Last Name' },\n];\n"})}),(0,i.jsxs)(n.p,{children:["When this array is assigned to the ",(0,i.jsxs)(n.a,{href:"../components/querybuilder#fields",children:[(0,i.jsx)(n.code,{children:"fields"})," prop"]}),", the ",(0,i.jsx)(n.code,{children:"fieldSelector"})," component will receive the same array but with each option object augmented with a ",(0,i.jsx)(n.code,{children:"value"})," property equivalent to the original ",(0,i.jsx)(n.code,{children:"name"}),":"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const MyFieldSelector = (props: FieldSelectorProps) => {\n  console.log(props.options); // =>\n  // [\n  //   { name: 'firstName', value: 'firstName', label: 'First Name' },\n  //   { name: 'lastName', value: 'lastName', label: 'Last Name' }],\n  // ]\n  return <ValueSelector {...props} />;\n};\n\nconst App = () => (\n  <QueryBuilder fields={fields} controlElements={{ fieldSelector: MyFieldSelector }} />\n);\n"})}),(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["If ",(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"value"})," differ for a given option, ",(0,i.jsx)(n.code,{children:"value"})," takes precedence."]})})]}),"\n",(0,i.jsx)(n.h2,{id:"workarounds",children:"Workarounds"}),"\n",(0,i.jsxs)(n.p,{children:["There are several ways to handle this ambiguity. One way is to cast option list props to ",(0,i.jsx)(n.code,{children:"Option[]"})," with the ",(0,i.jsx)(n.code,{children:"as"})," keyword. If your option list is ",(0,i.jsx)(n.em,{children:"definitely"})," ",(0,i.jsx)(n.code,{children:"Option[]"}),", this will probably work without causing issues. However, while the ",(0,i.jsx)(n.code,{children:"as"})," keyword may help avoid TypeScript errors, it has no effect on execution. Therefore it can be akin to lying to the TypeScript compiler (preventing it from doing its job), so this method is not recommended."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const MyComponent(props: ValueSelectorProps) => {\n  return <div>{(props.options as Option[]).map(opt => opt.name).join(', ')}</div>;\n  //                          ^^^^^^^^^^^ avoids TypeScript error; may have issues during execution\n};\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["All ",(0,i.jsx)(n.a,{href:"../utils/misc#defaults",children:"default option lists"})," (",(0,i.jsx)(n.code,{children:"defaultCombinators"}),", ",(0,i.jsx)(n.code,{children:"defaultOperators"}),", etc.) are type ",(0,i.jsx)(n.code,{children:"Option[]"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["Another solution is to use the ",(0,i.jsx)(n.a,{href:"#isoptiongrouparray",children:(0,i.jsx)(n.code,{children:"isOptionGroupArray"})})," type guard to determine if the option list is ",(0,i.jsx)(n.code,{children:"OptionGroup[]"}),'. This not only avoids the "lying" issue of the ',(0,i.jsx)(n.code,{children:"as"})," keyword, but also allows you to perform separate actions depending on whether the option list type is ",(0,i.jsx)(n.code,{children:"Option[]"})," or ",(0,i.jsx)(n.code,{children:"OptionGroup[]"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const MyComponent(props: ValueSelectorProps) => {\n  if (isOptionGroupArray(props.options)) {\n    return <div>{props.options.flatMap(og => og.options).map(opt => opt.name).join(', ')}</div>;\n  }\n  return <div>{(props.options).map(opt => opt.name).join(', ')}</div>;\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"utilities",children:"Utilities"}),"\n",(0,i.jsxs)(n.p,{children:["Several utility functions are available to help manage the dual-potential nature of option list props without the need for type guards or casting with ",(0,i.jsx)(n.code,{children:"as"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"getoption",children:(0,i.jsx)(n.code,{children:"getOption"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function getOption(arr: OptionList, identifier: string): Option;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Retrieves the full option object from an option list based on the given identifier (corresponding to ",(0,i.jsx)(n.code,{children:"name"})," or ",(0,i.jsx)(n.code,{children:"value"}),"), regardless of whether the list is ",(0,i.jsx)(n.code,{children:"Option[]"})," or ",(0,i.jsx)(n.code,{children:"OptionGroup[]"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"getOption(\n  [\n    { name: 'firstName', label: 'First Name' },\n    { name: 'lastName', label: 'Last Name' },\n  ],\n  'lastName'\n);\n// => { name: 'lastName', label: 'Last Name' }\n\ngetOption(\n  [\n    { label: 'First', options: [{ name: 'firstName', label: 'First Name' }] },\n    { label: 'Last', options: [{ name: 'lastName', label: 'Last Name' }] },\n  ],\n  'lastName'\n);\n// => { name: 'lastName', label: 'Last Name' }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getfirstoption",children:(0,i.jsx)(n.code,{children:"getFirstOption"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function getFirstOption(arr: OptionList): Option;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Retrieves the value of the identifier property (",(0,i.jsx)(n.code,{children:"name"})," or ",(0,i.jsx)(n.code,{children:"value"}),") of the first ",(0,i.jsx)(n.code,{children:"Option"})," in the list, regardless of whether the list is ",(0,i.jsx)(n.code,{children:"Option[]"})," or ",(0,i.jsx)(n.code,{children:"OptionGroup[]"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"QueryBuilder"})," uses this function to set default values for option lists in new rules and groups when no other method for determining the default value is provided."]}),"\n",(0,i.jsx)(n.h4,{id:"examples-1",children:"Examples"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"getFirstOption([\n  { name: 'firstName', label: 'First Name' },\n  { name: 'lastName', label: 'Last Name' },\n]);\n// => 'firstName'\n\ngetFirstOption([\n  { label: 'First', options: [{ name: 'firstName', label: 'First Name' }] },\n  { label: 'Last', options: [{ name: 'lastName', label: 'Last Name' }] },\n]);\n// => 'firstName'\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tooptions",children:(0,i.jsx)(n.code,{children:"toOptions"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function toOptions(arr: OptionList): ReactElement;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Generates an array of ",(0,i.jsx)(n.code,{children:"<option>"})," elements if the provided option list is an ",(0,i.jsx)(n.code,{children:"Option"})," array, or an array of ",(0,i.jsx)(n.code,{children:"<optgroup>"})," elements if the list is an ",(0,i.jsx)(n.code,{children:"OptionGroup"})," array. Intended for use as the ",(0,i.jsx)(n.code,{children:"children"})," prop on a ",(0,i.jsx)(n.code,{children:"<select>"})," element, as ",(0,i.jsx)(n.a,{href:"../components/valueselector",children:(0,i.jsx)(n.code,{children:"ValueSelector"})})," does."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Some of the ",(0,i.jsx)(n.a,{href:"../compat",children:"compatibility packages"})," implement their own ",(0,i.jsx)(n.code,{children:"toOptions"}),' method that generates "option" elements appropriate for their respective style library.']})}),"\n",(0,i.jsx)(n.h4,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const MyComponent(props: ValueSelectorProps) => {\n  return (\n    <select value={props.value} onChange={e => props.handleOnChange(e.target.value)}>\n      {toOptions(props.options)}\n    </select>\n  )\n}\n"})}),"\n",(0,i.jsxs)(r.A,{summary:"Examples",children:[(0,i.jsxs)(n.h4,{id:"option-example",children:[(0,i.jsx)(n.code,{children:"Option[]"})," example"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"toOptions([\n  { value: 'firstName', label: 'First Name' },\n  { value: 'lastName', label: 'Last Name' },\n]);\n// yields (approximately):\n[\n  <option key={'firstName'} value={'firstName'}>\n    First Name\n  </option>,\n  <option key={'lastName'} value={'lastName'}>\n    Last Name\n  </option>,\n];\n"})}),(0,i.jsxs)(n.h4,{id:"optiongroup-example",children:[(0,i.jsx)(n.code,{children:"OptionGroup[]"})," example"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"toOptions([\n  { label: 'First', options: [{ value: 'firstName', label: 'First Name' }] },\n  { label: 'Last', options: [{ value: 'lastName', label: 'Last Name' }] },\n]);\n// yields (approximately):\n[\n  <optgroup key={'First'} label={'First'}>\n    <option key={'firstName'} value={'firstName'}>\n      First Name\n    </option>\n  </optgroup>,\n  <optgroup key={'Last'} label={'Last'}>\n    <option key={'lastName'} value={'lastName'}>\n      Last Name\n    </option>\n  </optgroup>,\n];\n"})})]}),"\n",(0,i.jsx)(n.h3,{id:"toflatoptionarray",children:(0,i.jsx)(n.code,{children:"toFlatOptionArray"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function toFlatOptionArray(arr: any): boolean;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Flattens ",(0,i.jsx)(n.code,{children:"OptionGroup"})," arrays into ",(0,i.jsx)(n.code,{children:"Option"})," arrays using ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap",children:(0,i.jsx)(n.code,{children:"Array.prototype.flatMap"})}),", in case ",(0,i.jsx)(n.code,{children:"OptionGroup[]"})," is inappropriate or inapplicable, and leaves ",(0,i.jsx)(n.code,{children:"Option"})," arrays unmodified. The flattened list is de-duplicated using ",(0,i.jsx)(n.a,{href:"#uniqbyidentifier",children:(0,i.jsx)(n.code,{children:"uniqByIdentifier"})}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"isoptiongrouparray",children:(0,i.jsx)(n.code,{children:"isOptionGroupArray"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function isOptionGroupArray(arr: any): boolean;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A type guard to distiguish between the two different array types represented by ",(0,i.jsx)(n.code,{children:"OptionList"}),". If the result is ",(0,i.jsx)(n.code,{children:"true"}),", the array in question is an ",(0,i.jsx)(n.code,{children:"OptionGroup[]"}),", so the options themselves will be within an ",(0,i.jsx)(n.code,{children:"options"})," array property on each option group."]}),"\n",(0,i.jsx)(r.A,{summary:"Examples",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"isOptionGroupArray([\n  { value: 'firstName', label: 'First Name' },\n  { value: 'lastName', label: 'Last Name' },\n]);\n// => false\n\nisOptionGroupArray([\n  { label: 'First', options: [{ value: 'firstName', label: 'First Name' }] },\n  { label: 'Last', options: [{ value: 'lastName', label: 'Last Name' }] },\n]);\n// => true\n"})})}),"\n",(0,i.jsx)(n.h3,{id:"uniqoptlist",children:(0,i.jsx)(n.code,{children:"uniqOptList"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function uniqOptList(arr: any): boolean;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Removes duplicate options from an ",(0,i.jsx)(n.code,{children:"OptionList"})," based on a matching identifier properties (",(0,i.jsx)(n.code,{children:"name"})," or ",(0,i.jsx)(n.code,{children:"value"}),"), regardless of whether the list is ",(0,i.jsx)(n.code,{children:"Option[]"})," or ",(0,i.jsx)(n.code,{children:"OptionGroup[]"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"uniqbyidentifier",children:(0,i.jsx)(n.code,{children:"uniqByIdentifier"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function uniqByIdentifier(arr: any): boolean;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Removes duplicate options from an ",(0,i.jsx)(n.code,{children:"Option"})," array based on a matching identifier properties (",(0,i.jsx)(n.code,{children:"name"})," or ",(0,i.jsx)(n.code,{children:"value"}),")."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},18597:(e,n,t)=>{t.d(n,{A:()=>O});var i=t(62540),o=t(63696),r=t(11750),s=t(20218),l=t(20373),a=t(46732);const c={details:"details_IpIu",isBrowser:"isBrowser_QD4r",collapsibleContent:"collapsibleContent_Fd2D"};function d(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function p(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})),e}function h(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}function u(e){return!!e&&("SUMMARY"===e.tagName||u(e.parentElement))}function m(e,n){return!!e&&(e===n||m(e.parentElement,n))}function x(e){var{summary:n,children:t}=e,x=h(e,["summary","children"]);(0,s.A)().collectAnchor(x.id);const j=(0,l.A)(),f=(0,o.useRef)(null),{collapsed:y,setCollapsed:g}=(0,a.u)({initialState:!x.open}),[b,O]=(0,o.useState)(x.open),v=o.isValidElement(n)?n:(0,i.jsx)("summary",{children:null!=n?n:"Details"});return(0,i.jsxs)("details",p(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},i=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})))),i.forEach((function(n){d(e,n,t[n])}))}return e}({},x),{ref:f,open:b,"data-collapsed":y,className:(0,r.A)(c.details,j&&c.isBrowser,x.className),onMouseDown:e=>{u(e.target)&&e.detail>1&&e.preventDefault()},onClick:e=>{e.stopPropagation();const n=e.target;u(n)&&m(n,f.current)&&(e.preventDefault(),y?(g(!1),O(!0)):g(!0))},children:[v,(0,i.jsx)(a.N,{lazy:!1,collapsed:y,disableSSRStyle:!0,onCollapseTransitionEnd:e=>{g(e),O(!e)},children:(0,i.jsx)("div",{className:c.collapsibleContent,children:t})})]}))}const j={details:"details_jERq"};function f(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function y(){return y=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},y.apply(this,arguments)}function g(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})),e}const b="alert alert--info";function O(e){var n=y({},function(e){if(null==e)throw new TypeError("Cannot destructure "+e);return e}(e));return(0,i.jsx)(x,g(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},i=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})))),i.forEach((function(n){f(e,n,t[n])}))}return e}({},n),{className:(0,r.A)(b,j.details,n.className)}))}},41485:(e,n,t)=>{t.d(n,{K:()=>o});var i=t(62540);const o=({option:e,disabled:n=!1,text:t})=>(0,i.jsx)("a",{href:`/demo#${e}=${!n}`,children:t||"Click here for demo"+(n?" with this feature disabled":"")})},65404:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(63696);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);